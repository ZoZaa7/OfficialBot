
const Discord = require('discord.js');
const client = new Discord.Client();
client.on('ready', () => {
  console.log('bot online ');
});


client.on('message', message => { 
    var prefix = "$O";
    if (message.author.boss) return;
    if (!message.content.startsWith(prefix)) return;
    let command = message.content.split(" ")[0];
    command = command.slice(prefix.length);
    if (command == "role") {
    if (!message.channel.guild) return;
    if(!message.guild.member(message.author).hasPermission("MANAGE_ROLES")) return message.reply("**:no_entry_sign:Ø§Ù†Øª Ù„Ø§ ØªÙ…Ù„Ùƒ ØµÙ„Ø§Ø­ÙŠØ§Øª **").then(msg => msg.delete(5000));;
    if(!message.guild.member(client.user).hasPermission("MANAGE_ROLES")) return message.reply("Ø§Ù„Ø¨ÙˆØª Ù„Ø§ÙŠÙ…Ù„Ùƒ ØµÙ„Ø§Ø­ÙŠØ§Øª ").then(msg => msg.delete(5000));;
    let user = message.mentions.users.first();
    if (message.mentions.users.size < 1) return message.reply('**Ø¶Ø¹ Ù…Ù†Ø´Ù† Ø§Ù„Ø´Ø®Øµ!!**').then(msg => {msg.delete(5000)});
    let MRole = message.content.split(" ").slice(2).join(" ");
    if(!MRole)return message.reply("ÙŠØ¬Ø¨ Ø¹Ù„ÙŠÙƒ ÙˆØ¶Ø¹ Ø§Ø³Ù… Ø§Ù„Ø±ØªØ¨Ø©").then(msg => {msg.delete(5000)});
    message.guild.member(user).addRole(message.guild.roles.find("name", MRole));
    message.reply('*** Done :white_check_mark:  ***').then(msg => {msg.delete(10000)});
    }
    });



client.on('message', message => { 
    var prefix = "$O";
 let args = message.content.split(' ').slice(1);
    if(message.content.startsWith(prefix + 'short')) {
    if(!message.channel.guild) return;  

        googl.setKey('AIzaSyC2Z2mZ_nZTcSvh3QvIyrmOIFP6Ra6co6w');
        googl.getKey();
        googl.shorten(args.join(' ')).then(shorturl => {
            message.channel.send(''+shorturl)
        }).catch(e=>{
            console.log(e.message);
            message.channel.send('Error!');
        });
}
});





      const mmss = require('ms');
        client.on('message', async message => {
            let muteReason = message.content.split(" ").slice(3).join(" ");
            let mutePerson = message.mentions.users.first();
            let messageArray = message.content.split(" ");
            let muteRole = message.guild.roles.find("name", "Muted");
            let time = messageArray[2];
            if(message.content.startsWith(prefix + "tempmute")) {
                if(!message.member.hasPermission('MUTE_MEMBERS')) return message.channel.send('**Sorry But You Dont Have Permission** `MUTE_MEMBERS`' );
                if(!mutePerson) return message.channel.send('**Mention Someone**')
                if(mutePerson === message.author) return message.channel.send('**You Cant Mute Yourself**');
                if(mutePerson === client.user) return message.channel.send('**You Cant Mute The Bot**');
                if(message.guild.member(mutePerson).roles.has(muteRole.id)) return message.channel.send('**This Person Already Tempmuted !**');
                if(!muteRole) return message.guild.createRole({ name: "Muted", permissions: [] });
                if(!time) return message.channel.send("**Type The Duration**");
                if(!time.match(/[1-60][s,m,h,d,w]/g)) return message.channel.send('**The Bot Not Support This Time**');
                if(!muteReason) return message.channel.send('Please Type The Reason')
                message.guild.member(mutePerson).addRole(muteRole);
                message.channel.send(`**:white_check_mark: ${mutePerson} has been muted ! :zipper_mouth: **`)
                message.delete()
                let muteEmbed = new Discord.RichEmbed()
                .setTitle(`New Temp Muted User`)
                .setThumbnail(message.guild.iconURL)
                .addField('- Muted By:',message.author,true)
                .addField('- Muted User:', `${mutePerson}`)
                .addField('- Reason:',muteReason,true)
                .addField('- Duration:',`${mmss(mmss(time), {long: true})}`)
                .setFooter(message.author.username,message.author.avatarURL);
                let incidentchannel = message.guild.channels.find(`name`, `${log[message.guild.id].channel}`);
                if(!incidentchannel) return message.channel.send("Can't find log channel. To Set The Log Channel Type >setLog and answer the questions");
                incidentchannel.sendEmbed(muteEmbed)
                mutePerson.send(`**You Are has been temp muted in ${message.guild.name} reason: ${muteReason}**`)
                .then(() => { setTimeout(() => {
                   message.guild.member(mutePerson).removeRole(muteRole);
               }, mmss(time));
            });
            }
        });



client.on('message', message => {
	var prefix = "$O";
   if(message.content.startsWith(prefix + "invites")) {
    message.guild.fetchInvites().then(invs => {
      let user = message.mentions.users.first() || message.author
      let personalInvites = invs.filter(i => i.inviter.id === user.id);
      let inviteCount = personalInvites.reduce((p, v) => v.uses + p, 0);
               let mmmmEmbed = new Discord.RichEmbed()
                         .setAuthor(client.user.username)
                         .setThumbnail(message.author.avatarURL)
 .addField(` Ù„Ù‚Ø¯ Ù‚Ù…Øª Ø¨Ø¯Ø¹ÙˆØ© :`, ` ${inviteCount} `)
           .setFooter(`- Requested By: ${message.author.tag}`);
           message.channel.send(mmmmEmbed)
});
  }
});




client.on('message', message => {
    var args = message.content.split(/[ ]+/)
    if(message.content.includes('discord.gg')){
		if(!message.channel.guild) return;
        message.delete()
    return message.reply(`** No Invite Links Ù„Ù„Ø§Ø³Ù Ù…Ø§ ØªÙ‚Ø¯Ø± ØªÙ†Ø´Ø± :) Ù‡Ù‡Ù‡Ù‡Ù‡Ù‡Ù‡Ù‡Ù‡Ù‡Ø§ÙŠÙŠ ğŸ˜  ! **`)
    }
});






client.on("message", message => {
     if (message.content === "$Okick") {
         if(!message.channel.guild) return message.reply('** This command only for servers **');
        message.reply("bla bla")
     }
});




client.on("message", message => {
     if (message.content === "$Oban") {
         if(!message.channel.guild) return message.reply('** This command only for servers **');
        message.reply("bla bla")
     }
});







client.on('message', message => {
    if (message.content.startsWith("$Oavatar")) {
        var mentionned = message.mentions.users.first();
    var x5bzm;
      if(mentionned){
          var x5bzm = mentionned;
      } else {
          var x5bzm = message.author;
          
      }
        const embed = new Discord.RichEmbed()
        .setColor("RANDOM")
        .setImage(`${x5bzm.avatarURL}`)
      message.channel.sendEmbed(embed);
    }
});






client.on("message", message => {
    var prefix = "$O";
 
            var args = message.content.substring(prefix.length).split(" ");
            if (message.content.startsWith(prefix - "clear")) {
				if(!message.channel.guild) return;
   if(!message.member.hasPermission('MANAGE_MESSAGES')) return message.reply('âš  | *** âš  Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ù„Ùƒ Ù…Ø§Ù†Ø¬ Ù…Ø§Ø³Ø¬ ***');
        var msg;
        msg = parseInt();
      
      message.channel.fetchMessages({limit: msg}).then(messages => message.channel.bulkDelete(messages)).catch(console.error);
      message.channel.sendMessage("", {embed: {
        title: "Done | ØªÙ€Ù€Ù…",
        color: 0x06DF00,
        description: "ØªÙ… Ù…Ø³Ø­ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ Ø¨Ù†Ø¬Ø§Ø­",
        footer: {
          text: "Â© Premium Bot â„¢."
        }
      }}).then(msg => {msg.delete(3000)});
                          }

     
});


=


client.on('message', message => {
   if (message.content === "$Oid") {
   let embed = new Discord.RichEmbed()
  .setColor("RANDOM")
  .setThumbnail(message.author.avatarURL)
  .addField("Name:",`${message.author.username}`, true)
  .addField('Discrim:',"#" +  message.author.discriminator, true)
  .addField("ID:", message.author.id, true)
  .addField("Create At:", message.author.createdAt, true)
     
     
  message.channel.sendEmbed(embed);
    }
});





client.on("message", message => {
    var prefix = "$O";
            var args = message.content.substring(prefix.length).split(" ");
            if (message.content.startsWith(prefix + "clear")) {
 if (!args[1]) {
                                let x5bz1 = new Discord.RichEmbed()
                                .setDescription("-clear <number>")
                                .setColor("#0000FF")
                                message.channel.sendEmbed(x5bz1);
                            } else {
                            let messagecount = parseInt(args[1]);
                            message.channel.fetchMessages({limit: messagecount}).then(messages => message.channel.bulkDelete(messages));
                                                          message.channel.fetchMessages({limit: messagecount}).then(messages => message.channel.bulkDelete(messages));
                            message.channel.fetchMessages({limit: messagecount}).then(messages => message.channel.bulkDelete(messages));
                            let x5bz2 = new Discord.RichEmbed()
                                                            .setColor("#008000")
                                .setDescription(":white_check_mark: | Delete " + args[1] + " Message!")
                                                                                        message.delete("..");
                                message.channel.sendEmbed(x5bz2);
                            }
                          }
});





var prefix = "$O";
client.on('message', message => {
    if(message.content == prefix + 'server') {
        var servername = message.guild.name
        var Ø§ÙˆÙ†Ø± = message.guild.owner
        var Ø§Ø¹Ø¶Ø§Ø¡ = message.guild.memberCount
        var Ø§ÙŠØ¯ÙŠ = message.guild.id
        var Ø¨Ù„Ø¯Ø§Ù„Ø³ÙŠØ±ÙØ± = message.guild.region
        var Ø§Ù„Ø±ÙˆÙ…Ø§Øª = message.guild.channels.size
        var Ø§Ù„Ø±ØªØ¨ = message.guild.roles
        var Ø¹Ù…Ù„ = message.guild.createdAt
        var Ø§Ù„Ø±ÙˆÙ… = message.guild.defaultChannel
        var server = new Discord.RichEmbed()
        .setThumbnail(message.guild.iconURL)
        .addField('Ø§Ø³Ù… Ø§Ù„Ø³ÙŠØ±ÙØ±', servername)
        .addField('Ø§ÙŠ Ø¯ÙŠ Ø§Ù„Ø³ÙŠØ±ÙØ± ' , [Ø§ÙŠØ¯ÙŠ])
        .addField('Ø£Ø¹Ø¶Ø§Ø¡ Ø§Ù„Ø³ÙŠØ±ÙØ±', Ø§Ø¹Ø¶Ø§Ø¡)
        .addField('Ø±ÙˆÙ…Ø§Øª Ø§Ù„Ø³ÙŠØ±ÙØ±', Ø§Ù„Ø±ÙˆÙ…Ø§Øª)
        .addField('Ø±ÙˆÙ… Ø§Ù„Ø´Ø§Øª Ø§Ù„Ø£Ø³Ø§Ø³ÙŠ', Ø§Ù„Ø±ÙˆÙ…)
        .addField('ØµØ§Ø­Ø¨ Ø§Ù„Ø³ÙŠØ±ÙØ±', Ø§ÙˆÙ†Ø±)
        .addField('Ø¨Ù„Ø¯ Ø§Ù„Ø³ÙŠØ±ÙØ±', Ø¨Ù„Ø¯Ø§Ù„Ø³ÙŠØ±ÙØ±)
        .addField('ØªØ§Ø±ÙŠØ® Ø§ÙØªØªØ§Ø­ Ø§Ù„Ø³ÙŠØ±ÙØ±', Ø¹Ù…Ù„)
        .setColor('RANDOM')

        message.channel.sendEmbed(server)
    }
});



  const Discord = require('discord.js');
const client = new Discord.Client();
var prefix = "$O"

client.on('ready', () => {
  console.log(`Logged in as ${client.user.tag}!`);
  console.log('')
  console.log('')
  console.log('â•”[â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•]â•—')
  console.log(`[Start] ${new Date()}`);
  console.log('â•š[â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•]â•')
  console.log('')
  console.log('â•”[â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•]â•—');
  console.log(`Logged in as * [ " ${client.user.username} " ]`);
  console.log('')
  console.log('Informations :')
  console.log('')
  console.log(`servers! [ " ${client.guilds.size} " ]`);
  console.log(`Users! [ " ${client.users.size} " ]`);
  console.log(`channels! [ " ${client.channels.size} " ]`);
  console.log('â•š[â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•]â•')
  console.log('By Wenteed')
  console.log('â•”[â•â•â•â•â•â•â•â•â•â•â•â•]â•—')
  console.log(' Bot Is Online')
  console.log('â•š[â•â•â•â•â•â•â•â•â•â•â•â•]â•')
  console.log('')
  console.log('')

  
  


});
 
 
 
client.login(process.env.NTI1NzkxMjkwMDM4OTQzNzY0.Dv7xCg.gAnq083CcdhmjvZLEhqQUAp39Ik
);
